# -*- coding: utf-8 -*-
"""Deliverable 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F2SFHfOP73wTO-gTTmLJE2cuEA6YblPv
"""

from urllib.parse import urlparse
import re
import requests

def evaluate_url(url: str, timeout: int = 10) -> dict:
    """
    Returns: {"score": float (0â€“100), "explanation": str}
    """
    # 1) Validate URL
    try:
        parsed = urlparse(url.strip())
    except Exception:
        return {"score": 0.0, "explanation": "Invalid URL: parsing failed."}

    if parsed.scheme not in {"http", "https"} or not parsed.netloc:
        return {"score": 5.0, "explanation": "Invalid or unsupported URL scheme or missing domain."}

    score = 50.0
    reasons = []

    # 2) Simple heuristics (lightweight, explainable)
    # HTTPS bonus
    if parsed.scheme == "https":
        score += 10
        reasons.append("Uses HTTPS.")

    # Known low-signal TLD penalty (very rough)
    low_signal_tlds = {".buzz", ".info", ".top", ".click"}
    if any(parsed.netloc.endswith(tld) for tld in low_signal_tlds):
        score -= 10
        reasons.append("Low-trust TLD heuristic.")

    # Path depth penalty (very long/obscure paths can be spammy)
    path_depth = len([p for p in parsed.path.split('/') if p])
    if path_depth >= 6:
        score -= 5
        reasons.append("Deep/complex path.")

    # Suspicious query parameters
    if len(parsed.query) > 200:
        score -= 5
        reasons.append("Very long query string.")

    # 3) Lightweight reachability check
    try:
        r = requests.head(url, allow_redirects=True, timeout=timeout)
        if r.status_code >= 400:
            score -= 10
            reasons.append(f"HEAD status {r.status_code}.")
        else:
            reasons.append(f"Reachable (status {r.status_code}).")
    except requests.RequestException:
        score -= 15
        reasons.append("Unreachable (request error).")

    # Clamp & explain
    score = max(0.0, min(100.0, round(score, 2)))
    explanation = "; ".join(reasons) if reasons else "Baseline heuristics applied."
    return {"score": score, "explanation": explanation}

tests = [
    "", "not a url", "ftp://example.com/file",
    "http://example.com",
    "https://example.com/news/article?id=123",
    "https://totally-legit.buzz/free-money?x=" + "a"*500
]
for t in tests:
    print(t, "->", evaluate_url(t))
